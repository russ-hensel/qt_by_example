# -*- coding: utf-8 -*-
"""
Purpose:
    Help other examples, be examples,

    this code is not examples, but helpers for other examples
    like all the example code it uses f strings a lot so
    make sure you have some understanding of f strings
    all code here are helpers, not examples, but you
    may need to understand this code to understand the
    examples.

Example use:
    import sys
    sys.path.insert( 0, "/mnt/WIN_D/Russ/0000/python00/python3/_projects/stuffdb/ex_qt/")
    import ia_qt
    ia_qt.ia_obj( a_obj,
                 msg = None,
                       max_len         = None,
                       xin             = "",      # some sort of indent
                       print_it        = True,
                       sty             = "",
                       include_dir     = False,
                       )
"""
# ---- Search
"""
Search:

    evp          evaluate code
    exp          execute code
    eval
    exec
    combobox
    qlineedit

"""
# # --------------------
# if __name__ == "__main__":
#     #----- run the full app
#     import main
#     main.main()
# # --------------------


# ---- Imports

from PyQt5.QtSql import ( QSqlDatabase,
                          QSqlQueryModel, QSqlTableModel, QSqlQuery )
from PyQt5.QtSql import ( QSqlDatabase,              QSqlTableModel,
                           QSqlRelationalTableModel, QSqlRelation, QSqlRelationalDelegate, QSqlQuery, QSqlDriver, QSqlRecord )


from PyQt5.QtGui import (
    QStandardItemModel,
    QStandardItem,
                        )
# ---- QtCore
from PyQt5.QtCore  import  (
    QDate,
    QModelIndex,
    QTimer,
    Qt,
    QAbstractTableModel,
    pyqtSlot,
                            )

# ----QtWidgets
from PyQt5.QtWidgets import (
    QWidget,
    QPushButton,
    QAction,
    QDateEdit,
    QMenu,
    QAction,
    QLineEdit,
    QActionGroup,
    QApplication,
    QDockWidget,
    QTabWidget,
    QLabel,
    QListWidget,
    QMainWindow,
    QMessageBox,
    QSpinBox,
    QMdiSubWindow,
    QTextEdit,
    QButtonGroup,
    )

# ----QtWidgets big
from PyQt5.QtWidgets import (
    QAction,
    QMenu,
    QApplication,
    QMainWindow,
    QTableWidget,
    QTableView,
    QFrame,
    QMainWindow,
    QMdiArea,
    QMdiSubWindow,
    QMdiArea,
    QMdiSubWindow,
    )

# ----QtWidgets layouts
from PyQt5.QtWidgets import (
    QBoxLayout,
    QHBoxLayout,
    QVBoxLayout,
    QGridLayout,
    )

# ----QtWidgets Boxs, Dialogs
from PyQt5.QtWidgets import (
    QAction,
    QActionGroup,
    QDockWidget,
    QFileDialog,
    QInputDialog,

    QLabel,
    QListWidget,
    QMenu,
    QMessageBox,
    QPushButton,
    QSpinBox,
    QTextEdit,
    QVBoxLayout,
    QCheckBox,
    QComboBox,
    )

from PyQt5.QtGui import (
    QIntValidator,
    )

# ---- QtSql
from PyQt5.QtSql import (
    QSqlDatabase,
    QSqlTableModel,
    QSqlQuery,
    QSqlError,
    QSqlRecord,
    QSqlField,

    )


# delap some imports so that environments
# that do not include them may still run


#import pandas as pd
#import numpy as np
#import sys
#import pprint
import io
import time
import collections
import pprint
from   pprint   import pprint as pp
from   datetime import datetime
from   collections.abc import Sequence

#import Series
#import DataFrame
#import pandas as pd
import sys
#from   pandas import Series, DataFrame
#import table_model

# ---- end imports


ExecEval        = collections.namedtuple( 'ExecEval', "an_except, eval_str, eval_to" )

"""
an_except    exception raised or None,
eval_except_str   string generated by function
eval_to           object the eval generated ( do not use if exception
"""

DEBUGGING       = False  # in testing may be changed externally

indent_0        = "   " # used for formatting
INDENT          = "    "
INDENT2         = INDENT

MAX_REPR_LEN    = 150 #
MAX_STR_LEN     = 150 #
MAX_LIST_ITEMS  = 8

common_dir_items  = (
['__module__',
 '__lt__',
 '__le__',
 '__eq__',
 '__ne__',
 '__gt__',
 '__ge__',
 '__weakref__',
 '__doc__',
 '__hash__',
 '__new__',
 '__init__',
 '__dict__',
 '__repr__',
 '__str__',
 '__getattribute__',
 '__setattr__',
 '__delattr__',
 '__reduce_ex__',
 '__reduce__',
 '__subclasshook__',
 '__init_subclass__',
 '__format__',
 '__sizeof__',
 '__dir__',
 '__class__']
)

more_common_dir_items  = (
[ "__iter__", "__mod__", "__rmod__",

 "__len__", "__getitem__", "__add__", "__mul__", "__rmul__", "__contains__" ] )

common_dir_items = common_dir_items  + more_common_dir_items


if DEBUGGING:my_type       =  QSqlQueryModel


dispatch_dict  = {}   # defined later search -- but search seq so nee not be a dict



msg_prefix  = "\n>>>> "
def default_msg( type_as_string ):

    msg   = f"{msg_prefix}for instance of  {type_as_string}"

    return msg

# ---------------------
def to_columns( current_str, item_list, format_list = ( "{: <30}", "{:<30}" ), indent = "    "  ):
    """
    for __str__  probably always default format_list
    see ColunmFormatter which is supposed to be more elaborate version
    see its __str__
    ex:
        import string_util
        a_str     = string_util.to_columns( a_str, ["column_data",    f"{self.column_data}"  ] )
        a_str     = string_util.to_columns( a_str,
                                            ["column_data",    f"{self.column_data}"  ],
                                            format_list = ( "{: <30}", "{:<30}" )
    """
    #rint ( f"item_list {item_list}.............................................................. " )
    line_out  = ""
    for i_item, i_format in zip( item_list, format_list ):
        a_col  = i_format.format( i_item )
        line_out   = f"{indent}{line_out}{a_col}"
    if current_str == "":
        ret_str  = f"{line_out}"
    else:
        ret_str  = f"{current_str}\n{line_out}"
    return ret_str

# ----------------------------------------
class StreamDiverter(  ):
    """
    !! check for sys in the globals
    or use our sys and add back
    """
    # ------------------
    def __init__( self, the_globals ):

        test_sys   = the_globals.get( "sys", None )
        if test_sys is None:
            print( "please include sys in remote module -- why not import here!!!")
            1/0

        self.saved_stdout      = None
        self.a_string_io       = io.StringIO( "" )
        self.the_globals       = the_globals   # may or may not need
        self.diverted_stream   = None

        #print( f'   got sys?? {self.the_globals[ "sys" ]} '  )
        #check_key( "", the_globals, "sys" )

    # ------------------
    def divert_stdout( self,   ):
        """
        divert stdout
        could replace all of sys
        ?? add protection against double use?
        may not need with use a a_str
        """
        a_string_io        = io.StringIO( "some initial text data" )

        self.saved_stdout  = sys.stdout
        # f = open('out.txt', 'w')
        sys.stdout                         = self.a_string_io
        self.the_globals[ "sys" ].stdout   = self.a_string_io

    # ------------------
    def restore_stdout( self, ):
        """
        what it says read
        ?? add protection
        perhaps get content here
        """
        sys.stdout                         = self.saved_stdout
        self.the_globals[ "sys" ].stdout   = self.saved_stdout
        self.saved_stdout                  = None

        self.diverted_stream               = self.a_string_io.getvalue()

        #rint ( "restore_stdout done" )

    # ------------------
    def get_diverted_lines( self, ):
        """
        what it says, read
        returns a list

        """
        lines    =  self.diverted_stream.split( "\n")
        return lines




# ----------- helper helper

def not_instance( msg, my_type, my_type_str, a_obj, xin  ) :
    """
    returns
        string with message

    """
    a_str   = ""
    a_str   = ( f"{xin}{a_str}{msg} object is not an instance "
                     f"of {my_type_str} but is {type(a_obj)}" )

    return a_str

def short_repr( a_obj, max_len = MAX_REPR_LEN ):
    """
    make a repr, shorten if too long
    read code
    consider ret of is truncated in tuple

    """
    a_str  = repr( a_obj )

    if len( a_str ) > max_len:
        a_str  = a_str[ :max_len ] + "..."

    return a_str

# -----------
def short_str( a_obj, max_len = MAX_STR_LEN ):
    """
    make a str, shorten if too long
    read code
    consider ret of is truncated in tuple

    """
    a_str  = repr( a_obj )

    if len( a_str ) > max_len:
        a_str  = a_str[ :max_len ] + "..."
    return a_str

# ---- Info functions -- print a nice set of info about an object
# ----------------------------------------
def  ia_obj(        a_obj,
                    msg = None,
                    *,
                    max_len         = None,
                    xin             = "",      # some sort of indent
                    print_it        = True,
                    sty             = "",
                    include_dir     = False,
                    ):
    """
    doc is out of date
    Purpose:
        returns info as a string, and may print information about objects
        sort of a pretty print +
        has some isinstance branching to get the right  display
        this branches to right function for ease of calling
        may want to add more cases for different types
    args:
        a_obj    an object to examine
        msg      msg to be printed along with the other info -- if "" suppress or default?
        print_it    = bool   True = print else just return a string
        xin         = amount of extra indentation
        sty         = style   s = standard
                                v = verbose
                                t = tiny   m = minimal
                                c = compact

    Returns:
        str or may prints output
    Example Call:
        ex_helpers.ia_obj( a_obj, msg = "ia_obj:" )
    """
    debug   = False
    a_str   = "look for missing assignment"

    # fast case statement think want more specialized first
    for my_type, type_tuple in   dispatch_dict.items( ):
        debug_my_type          =  my_type
        function, type_string  = type_tuple
        print( my_type )
        # next for debugging only
        #rint( f"ia_obj debug {my_type = }, {function = }, {type_string = }, ")
        if isinstance( a_obj, my_type):
            if debug:
                print( f"off to {type_string} >>>>>>>>>>" )
            a_str   = function ( a_obj,
                                    msg = None,
                                    max_len         = None,
                                    xin             = "",      # some sort of indent
                                    print_it        = True,
                                    sty             = "",
                                    include_dir     = False,
                        )
            break
    else:
        # THIS IS not really right shoudl use other args and wrte to string
        print( f"no inspect (ia_obj) found for {a_obj = } \n     {msg}")
    return  a_str

# ----------------------------------------
def  ia_obj_old( a_obj,
                    msg = None,
                    *,
                    max_len         = None,
                    xin             = "",      # some sort of indent
                    print_it        = True,
                    sty             = "",
                    include_dir     = False,
                    ):
    """
    Purpose:
        returns info as a string, and may print information about objects
        sort of a pretty print +
        has some isinstance branching to get the right  display
        this branches to right function for ease of calling
        may want to add more cases for different types
    args:
        a_obj    an object to examine
        msg      msg to be printed along with the other info -- if "" suppress or default?
        print_it    = bool   True = print else just return a string
        xin         = amount of extra indentation
        sty         = style   s = standard
                                v = verbose
                                t = tiny   m = minimal
                                c = compact

    Returns:
        str or may prints output
    Example Call:
        ex_helpers.ia_obj( a_obj, msg = "ia_obj:" )
    """
    debug   = False
    a_str   = "look for missing assignment"
    #found    = True
    # if  isinstance( a_obj, list ):
    #     if debug:
    #         print( "off to ia_list")
    #     a_str   = ia_list( a_obj, msg )

    # !! set up a dict, det the dict is instance, then just one call
    if   isinstance(  a_obj,  QSqlTableModel ):
        if debug:
            print( "off to QSqlTableModel >>>>>>>>>>" )
        a_str   = q_sql_table_model ( a_obj,
                                msg = None,
                                max_len         = None,
                                xin             = "",      # some sort of indent
                                print_it        = True,
                                sty             = "",
                                include_dir     = False,
                                )

    elif isinstance(  a_obj,  QSqlQueryModel ):
        if debug:
            print( "off to QSqlQueryModel >>>>>>>>>>" )
        a_str   = q_sql_query_model ( a_obj,
                                msg = None,
                                max_len         = None,
                                xin             = "",      # some sort of indent
                                print_it        = True,
                                sty             = "",
                                include_dir     = False,
                                )


    # elif isinstance( a_obj, DataFrame ):
    #     ia_dataframe( a_obj, msg )

    # elif isinstance( a_obj, DataFrame ):
    #     ia_dataframe( a_obj, msg )

    else:
        if debug:
            print( "default info >>>>>>>>>>" )
        a_str   = ""
        #print(  "\n!!!! ia_obj ---- did not identify object type" )
        a_str   = f"{xin}{a_str}for msg = {msg} object x is of Type {type(a_obj)}"
        a_str   = f"{xin}{a_str}\n{INDENT}>{a_obj}<"
        a_str   = f"{xin}{a_str}\n{INDENT}type is = { str( type(a_obj) ) }"
        a_str   = f"{xin}{a_str}\n{INDENT}str     = {str( a_obj )}"
        a_str   = f"{xin}{a_str}\n{INDENT}repr    = {repr(a_obj )}"

    a_str   = f"{xin}{a_str}\n{INDENT}------\n"

    if print_it:
        #print( ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
        print( a_str  )

    return a_str

# ----------------------------------------
def  q_abstract_table_model( a_obj,
                        msg = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        ):
    """
    Purpose:
        prints information about QAbstractTableModel() q_sql_table_model
        see inof_about_obj
        __dir__()     =
        print(
            msg    = "here i am...... "
            ia_qt.q_sql_table_model( model, msg = msg,    )

    """
    print( a_obj, type( a_obj ))
    my_type       =  QAbstractTableModel
    my_type_str   = "QAbstractTableModel"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "

    if  isinstance(  a_obj,  my_type  ):

        max_items  = MAX_LIST_ITEMS
        a_str   = ""

        nl_if  = "\n"
        if msg is not None:
            a_str   = f"\n{xin}{a_str}>>>{msg}"
        nl_if  = ""
        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_str   = f"{a_str}\n{xin}{INDENT2}type is = { str( type(a_obj) ) }"

        a_repr  = short_repr( a_obj )
        a_str   = f"{a_str}\n{xin}{INDENT2}repr    = {a_repr}"

        a_str   = f"{a_str}\n{xin}{INDENT2}rowCount()     = {a_obj.rowCount() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}isDirty()      = {a_obj.isDirty() }"  for sql

        max_rows   = a_obj.rowCount()

        for ix_row in range( 0, max_rows ):
        #if a_obj.rowCount( ) > 0:
            # make an index
            ix_col      = 1
            index       = a_obj.index(  ix_row, ix_col )

            if False:   # do not have records   -- think has data and can index into see picture_document
                a_record    =  a_obj.record( ix_row )
                str_2       =  q_record( a_record,
                                            msg      = None,
                                            max_len  = None,
                                            xin      = "    ",
                                            print_it = False,
                                            sty      = "",
                                            include_dir  = False,
                                            details_only = True,
                                    )
                a_str        = f"{a_str}\n{str_2}"
        # a_str   = f"{a_str}\n{xin}{INDENT2}bindValue  meth    = {a_obj.bindValue }"

        # #a_str   = f"{a_str}\n{xin}{INDENT2}bindValue  function    = {a_obj.bindValue }"
        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
# ---- q_record ( a_obj, no such thing


# ----------------------------------------
def  q_sql_query( a_obj,
                        msg = None,
                        *,
                        max_len         = None,
                        xin             = "",      # some sort of indent
                        print_it        = True,
                        sty             = "",
                        include_dir     = False,
                        ):

    """

    """
    my_type       =  QSqlQuery
    my_type_str   = "QSqlQuery"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "

    if  isinstance(  a_obj, my_type  ):
        max_items  = MAX_LIST_ITEMS

        a_str = ""

        nl_if  = "\n"

        if msg is not None:
            a_str   = f"\n{xin}{a_str}>>>{msg}"
        nl_if  = ""
        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        # next may be redundant
        # a_str   = f"{a_str}\n{xin}{INDENT2}type is           = { str( type(a_obj) ) }"
        # a_repr  = short_repr( a_obj )
        # a_str   = f"{a_str}\n{xin}{INDENT2}repr              = {a_repr}"

        #a_str   = f"{a_str}\n{xin}{INDENT2}len           = {len(a_obj)}"


        a_str   = f"{a_str}\n{xin}{INDENT2}bindValue()       = {a_obj.bindValue }"
        a_str   = f"{a_str}\n{xin}{INDENT2}boundValues()     = {a_obj.boundValues() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}isActive()        = {a_obj.isActive() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}isSelect()        = {a_obj.isSelect() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}isValid()         = {a_obj.isValid() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}lastError()       = {a_obj.lastError() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}lastInsertId()    = {a_obj.lastInsertId() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}lastQuery()       = {a_obj.lastQuery() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}record()          = {a_obj.record() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}size()            = {a_obj.size() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}isValid()         = {a_obj.isValid() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}value( 1 )     = {a_obj.value( 1 ) }"
        #         # easily causes an exception


        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"
        # ix = 0
        # for  i_value in a_obj:

        #     a_str   = f"{a_str}\n{INDENT2}{i_value}"
        #     ix += 1
        #     if ix > max_items:

        #         a_str   = f"{a_str}\n{INDENT}and {len(a_obj) - max_items} more items.... "
        #         break

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_sql_query_model( a_obj,
                        msg = None,
                        *,
                        max_len         = None,
                        xin             = "",      # some sort of indent
                        print_it        = True,
                        sty             = "",
                        include_dir     = False,
                        ):

    """
    """
    my_type       =  QSqlQueryModel
    my_type_str   = "QSqlQueryModel"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "

    if  isinstance(  a_obj, my_type  ):
        max_items   = MAX_LIST_ITEMS
        a_str       = ""
        nl_if       = "\n"

        if msg is not None:   # !! really
            a_str   = f"\n{xin}{a_str}>>>{msg}"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_str   = f"{a_str}\n{xin}{INDENT2}lastError().isValid()    = {a_obj.lastError().isValid() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}lastError().text()       = {a_obj.lastError().text() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}rowCount()               = {a_obj.rowCount() } records"
        if a_obj.rowCount( ) > 0:
            a_str   = f"{a_str}\n{xin}{INDENT2}... records record(0):"
            a_record    =  a_obj.record( 0 )
            str_2       =  q_sql_record( a_record,
                                        msg      = None,
                                        max_len  = None,
                                        xin      = "    ",
                                        print_it = False,
                                        sty      = "",
                                        include_dir  = False,
                                        details_only = True,
                                )

            a_str   = f"{a_str}{str_2}"

        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_abstract_table_model( a_obj,
                        msg = None,
                        *,
                        max_len         = None,
                        xin             = "",      # some sort of indent
                        print_it        = True,
                        sty             = "",
                        include_dir     = False,
                        ):
    """
    do not forget help( QSqlTableModel ) works
    Purpose:
    """
    my_type       =  QAbstractTableModel
    my_type_str   = "QAbstractTableModel"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "

    if  isinstance(  a_obj, my_type  ):
        max_items  = MAX_LIST_ITEMS

        a_str = ""

        nl_if  = "\n"

        if msg is not None:  # !! really
            a_str   = f"\n{xin}{a_str}>>>{msg}"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        # a_str   = f"{a_str}\n{xin}{INDENT2}lastError().isValid()    = {a_obj.lastError().isValid() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}lastError().text()       = {a_obj.lastError().text() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}rowCount()               = {a_obj.rowCount() } records"
        a_str   = f"{a_str}\n{xin}{INDENT2}_data                = {a_obj._data  }    "
        a_str   = f"{a_str}\n{xin}{INDENT2}_headers                = {a_obj._headers }    "
        # if a_obj.rowCount( ) > 0:
        #     a_str   = f"{a_str}\n{xin}{INDENT2}... records record(0):"
        #     a_record    =  a_obj.record( 0 )
        #     str_2       =  q_sql_record( a_record,
        #                                 msg      = None,
        #                                 max_len  = None,
        #                                 xin      = "    ",
        #                                 print_it = False,
        #                                 sty      = "",
        #                                 include_dir  = False,
        #                                 details_only = True,
        #                         )

            # a_str   = f"{a_str}{str_2}"

        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  model_indexer( a_obj,
                        msg = None,
                        *,
                        max_len         = None,
                        xin             = "",      # some sort of indent
                        print_it        = True,
                        sty             = "",
                        include_dir     = False,
                        ):
    """
    not doe see str method of ModelIndexer
    """
    ModelIndexer  = table_model.ModelIndexer
    my_type       =  ModelIndexer
    my_type_str   = "ModelIndexer"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "

    if  isinstance(  a_obj, my_type  ):
        max_items   = MAX_LIST_ITEMS
        a_str       = ""
        nl_if       = "\n"

        if msg is not None:
            a_str   = f"\n{xin}{a_str}>>>{msg}"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        # a_str   = f"{a_str}\n{xin}{INDENT2}lastError().isValid()    = {a_obj.lastError().isValid() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}lastError().text()       = {a_obj.lastError().text() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}rowCount()               = {a_obj.rowCount() } records"
        a_str   = f"{a_str}\n{xin}{INDENT2}_data                = {a_obj._data  }    "
        a_str   = f"{a_str}\n{xin}{INDENT2}_headers                = {a_obj._headers }    "
        # if a_obj.rowCount( ) > 0:
        #     a_str   = f"{a_str}\n{xin}{INDENT2}... records record(0):"
        #     a_record    =  a_obj.record( 0 )
        #     str_2       =  q_sql_record( a_record,
        #                                 msg      = None,
        #                                 max_len  = None,
        #                                 xin      = "    ",
        #                                 print_it = False,
        #                                 sty      = "",
        #                                 include_dir  = False,
        #                                 details_only = True,
        #                         )

            # a_str   = f"{a_str}{str_2}"

        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_sql_table_model( a_obj,
                        msg = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        ):
    """
    Purpose:
        prints information about QSqlTableModel() q_sql_table_model
        see inof_about_obj
        __dir__()     =
        print(
            msg    = "here i am...... "
            ia_qt.q_sql_table_model( model, msg = msg,    )

    """
    print( a_obj, type( a_obj ))
    my_type       =  QSqlTableModel
    my_type_str   = "QSqlTableModel"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "



    if  isinstance(  a_obj,  QSqlTableModel  ):

        max_items  = MAX_LIST_ITEMS
        a_str   = ""
        nl_if  = "\n"

        if msg is not None:   # !! really
            a_str   = f"\n{xin}{a_str}>>>{msg}"
        nl_if  = ""
        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_str   = f"{a_str}\n{xin}{INDENT2}type is = { str( type(a_obj) ) }"
        #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
        a_repr  = short_repr( a_obj )
        a_str   = f"{a_str}\n{xin}{INDENT2}repr    = {a_repr}"

        a_str   = f"{a_str}\n{xin}{INDENT2}database()     = {a_obj.database() }"

        a_str   = f"{a_str}\n{xin}{INDENT2}rowCount()     = {a_obj.rowCount() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}isDirty()      = {a_obj.isDirty() }"

        max_rows   = a_obj.rowCount()

        # choose onne
        max_dirty  = 5
        max_clean  = 5

        max_dirty  = max_rows
        max_clean  = max_rows

        ix_dirty   = 0
        ix_clean   = 0
        for ix_row in range( 0, a_obj.rowCount() ):
        #if a_obj.rowCount( ) > 0:
            # make an index
            # records do not seem to kno if they are dirty
            ix_col      = 1
            index       = a_obj.index(  ix_row, ix_col )
            is_dirty    = a_obj.isDirty( index )    # apparently field by field so....
            do_record   = False
            if   is_dirty and ( ix_dirty < max_dirty ):
                ix_dirty    += 1
                a_str        = f"{a_str}\n{xin}{INDENT2}index {ix_row}, {ix_col} isDirty()      = {is_dirty}"
                do_record    = True
            elif ( not is_dirty ) and ix_clean < max_clean:
                ix_clean    += 1
                a_str        = f"{a_str}\n{xin}{INDENT2}index {ix_row} {ix_col} isDirty()      = {is_dirty}"
                do_record    = True
            elif ( ix_clean >= max_clean ) and (ix_dirty >= max_dirty ):
                break

            if do_record:
                a_record    =  a_obj.record( ix_row )
                str_2       =  q_sql_record( a_record,
                                            msg      = None,
                                            max_len  = None,
                                            xin      = "    ",
                                            print_it = False,
                                            sty      = "",
                                            include_dir  = False,
                                            details_only = True,
                                    )
                a_str        = f"{a_str}\n{str_2}"
        # a_str   = f"{a_str}\n{xin}{INDENT2}bindValue  meth    = {a_obj.bindValue }"

        # a_str   = f"{a_str}\n{xin}{INDENT2}boundValues()      = {a_obj.boundValues() }"
        # #a_str   = f"{a_str}\n{xin}{INDENT2}bindValue  function    = {a_obj.bindValue }"
        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_sql_relational_table_model( a_obj,
                        msg = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        details_only = False,
                        ):
    """


    """
    #rint( a_obj, type( a_obj ))
    my_type       =  QSqlRelationalTableModel
    my_type_str   = "QSqlRelationalTableModel"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "

    if  isinstance(  a_obj,  my_type  ):

        max_items   = MAX_LIST_ITEMS
        a_str       = ""
        nl_if       = "\n"
        nl_if       = ""
        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"
        if not details_only:
            a_str   = f"{xin}{a_str}for msg = {msg}"

            a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

            a_str   = f"{a_str}\n{xin}{INDENT2}type is      = { str( type(a_obj) ) }"
            #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
            a_repr  = short_repr( a_obj )
            a_str   = f"{a_str}\n{xin}{INDENT2}repr         = {a_repr}"

        #a_str   = f"{a_str}\n{xin}{INDENT2}database()     = {a_obj.database() }"

        a_str   = f"{a_str}\n{xin}{INDENT2}rowCount()     = {a_obj.rowCount() }"
        # if a_obj.rowCount( ) > 0:
        #     a_record    =  a_obj.record( 0 )
        #     str_2       =  q_sql_record( a_record,
        #                                 msg      = None,
        #                                 max_len  = None,
        #                                 xin      = "",
        #                                 print_it = False,
        #                                 sty      = "",
        #                                 include_dir  = False,
        #                                 details_only = True,
        #                         )
        # a_str   = f"{a_str}\n{xin}{INDENT2}bindValue  meth    = {a_obj.bindValue }"

        # a_str   = f"{a_str}\n{xin}{INDENT2}boundValues()      = {a_obj.boundValues() }"
        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_table_widget( a_obj,
                        msg = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        details_only = False,
                        ):
    """

    """
    #rint( a_obj, type( a_obj ))
    my_type       =  QTableWidget
    my_type_str   = "QTableWidget"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "


    if  isinstance(  a_obj,  my_type  ):

        max_items   = MAX_LIST_ITEMS
        a_str       = ""
        nl_if       = "\n"
        nl_if       = ""

        if msg is not None:
            a_str   = f"\n{xin}{a_str}>>>{msg}"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_str   = f"{a_str}\n{xin}{INDENT2}type is = { str( type(a_obj) ) }"
        #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
        a_repr  = short_repr( a_obj )
        a_str   = f"{a_str}\n{xin}{INDENT2}repr    = {a_repr}"

        a_str   = f"{a_str}\n{xin}{INDENT2}rowCount()     = {a_obj.rowCount() }"
        # if a_obj.rowCount( ) > 0:
        #     a_record    =  a_obj.record( 0 )
        #     str_2       =  q_sql_record( a_record,
        #                                 msg      = None,
        #                                 max_len  = None,
        #                                 xin      = "",
        #                                 print_it = False,
        #                                 sty      = "",
        #                                 include_dir  = False,
        #                                 details_only = True,
        #                         )
        # a_str   = f"{a_str}\n{xin}{INDENT2}bindValue  meth    = {a_obj.bindValue }"

        # a_str   = f"{a_str}\n{xin}{INDENT2}boundValues()      = {a_obj.boundValues() }"
        # #a_str   = f"{a_str}\n{xin}{INDENT2}bindValue  function    = {a_obj.bindValue }"
        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_sql_table_widget( a_obj,
                        msg = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        details_only = False,
                        ):
    """

    """
    my_type       =  QSqlTableWidget
    my_type_str   = "QSqlTableWidget"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "



    if  isinstance(  a_obj,  my_type  ):

        max_items   = MAX_LIST_ITEMS
        a_str       = ""
        nl_if       = "\n"
        nl_if       = ""

        if msg is not None:
            a_str   = f"\n{xin}{a_str}>>>{msg}"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_str   = f"{a_str}\n{xin}{INDENT2}type is = { str( type(a_obj) ) }"
        #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
        a_repr  = short_repr( a_obj )
        a_str   = f"{a_str}\n{xin}{INDENT2}repr    = {a_repr}"

        #a_str   = f"{a_str}\n{xin}{INDENT2}database()     = {a_obj.database() }"

        a_str   = f"{a_str}\n{xin}{INDENT2}rowCount()     = {a_obj.rowCount() }"
        # if a_obj.rowCount( ) > 0:
        #     a_record    =  a_obj.record( 0 )
        #     str_2       =  q_sql_record( a_record,
        #                                 msg      = None,
        #                                 max_len  = None,
        #                                 xin      = "",
        #                                 print_it = False,
        #                                 sty      = "",
        #                                 include_dir  = False,
        #                                 details_only = True,
        #                         )
        # a_str   = f"{a_str}\n{xin}{INDENT2}bindValue  meth    = {a_obj.bindValue }"

        # a_str   = f"{a_str}\n{xin}{INDENT2}boundValues()      = {a_obj.boundValues() }"
        # #a_str   = f"{a_str}\n{xin}{INDENT2}bindValue  function    = {a_obj.bindValue }"
        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_sql_error( a_obj, msg = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        ):
    """
    """
    my_type       =  QSqlError
    my_type_str   = "QSqlError"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "

    if  isinstance(  a_obj, my_type  ):

        max_items   = MAX_LIST_ITEMS
        a_str       = msg
        nl_if       = "\n"
        nl_if       = ""

        if msg is not None:
            a_str   = f"\n{xin}{a_str}>>>{msg}"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_str   = f"{a_str}\n{xin}{INDENT2}type is = { str( type(a_obj) ) }"
        #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
        a_repr  = short_repr( a_obj )
        a_str   = f"{a_str}\n{xin}{INDENT2}repr    = {a_repr}"
        a_str   = f"{a_str}\n{xin}{INDENT2}isValid()          = {a_obj.isValid() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}databaseText()     = {a_obj.databaseText() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}driverText()       = {a_obj.driverText() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}driverText()       = {a_obj.driverText() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}text()             = {a_obj.text() }"

        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"

        # a_str   = f"{a_str}\n{xin}{INDENT2}boundValues()      = {a_obj.boundValues() }"
        # #a_str   = f"{a_str}\n{xin}{INDENT2}bindValue  function    = {a_obj.bindValue }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_sql_database( a_obj,
                        msg = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        details_only = False,
                        ):
    """
    #import ia_qt
    print(  ia_qt.q_sql_database( obj,
                                  msg            = "in test_db()...",
                                  include_dir    = True ) )

    """
    my_type       =  QSqlDatabase
    my_type_str   = "QSqlDatabase"

    if msg is not None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "

    if  isinstance(  a_obj, my_type ):

        max_items   = MAX_LIST_ITEMS
        a_str       = ""
        nl_if       = "\n"
        nl_if       = ""

        a_srep  = short_str( a_obj )
        if not details_only:
            a_str   = f"{xin}{a_str}for msg = {msg}"

            a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

            a_str   = f"{a_str}\n{xin}{INDENT2}type is      = { str( type(a_obj) ) }"
            #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
            a_repr  = short_repr( a_obj )
            a_str   = f"{a_str}\n{xin}{INDENT2}repr         = {a_repr}"

        a_str   = f"{a_str}\n{xin}{INDENT2}isOpen()     = {a_obj.isOpen() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}tables()     = {a_obj.tables() }"

        a_str   = f"{a_str}\n{xin}{INDENT2}database()       = {a_obj.database() }"

        a_str   = f"{a_str}\n{xin}{INDENT2}databaseName()   = {a_obj.databaseName() }"

        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"

        # #a_str   = f"{a_str}\n{xin}{INDENT2}bindValue  function    = {a_obj.bindValue }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_sql_record ( a_obj,
                        msg             = None,
                        *,
                        max_len         = None,
                        xin             = "",
                        print_it        = True,
                        sty             = "",
                        include_dir     = False,
                        details_only    = False,
                        ):
    """

          append                        <built-in method append of QSqlRecord object at 0x7f69f84cc3c0>
          clear                         <built-in method clear of QSqlRecord object at 0x7f69f84cc3c0>
          clearValues                   <built-in method clearValues of QSqlRecord object at 0x7f69f84cc3c0>
          contains                      <built-in method contains of QSqlRecord object at 0x7f69f84cc3c0>
          count                         <built-in method count of QSqlRecord object at 0x7f69f84cc3c0>
          field                         <built-in method field of QSqlRecord object at 0x7f69f84cc3c0>
          fieldName                     <built-in method fieldName of QSqlRecord object at 0x7f69f84cc3c0>
          indexOf                       <built-in method indexOf of QSqlRecord object at 0x7f69f84cc3c0>
          insert                        <built-in method insert of QSqlRecord object at 0x7f69f84cc3c0>
          isEmpty                       <built-in method isEmpty of QSqlRecord object at 0x7f69f84cc3c0>
          isGenerated                   <built-in method isGenerated of QSqlRecord object at 0x7f69f84cc3c0>
          isNull                        <built-in method isNull of QSqlRecord object at 0x7f69f84cc3c0>
          keyValues                     <built-in method keyValues of QSqlRecord object at 0x7f69f84cc3c0>
          remove                        <built-in method remove of QSqlRecord object at 0x7f69f84cc3c0>
          replace                       <built-in method replace of QSqlRecord object at 0x7f69f84cc3c0>
          setGenerated                  <built-in method setGenerated of QSqlRecord object at 0x7f69f84cc3c0>
          setNull                       <built-in method setNull of QSqlRecord object at 0x7f69f84cc3c0>
          setValue                      <built-in method setValue of QSqlRecord object at 0x7f69f84cc3c0>
          value                         <built-in method value of QSqlRecord object at 0x7f69f84cc3c0>
   next_key = None


    #import ia_qt
    print(  ia_qt.q_sql_record( obj,
                                  msg            = "in test_db()...",
                                  include_dir    = True,
                                  ) )

    """
    my_type       =  QSqlRecord
    my_type_str   = "QSqlRecord"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "

    if  isinstance(  a_obj, my_type ):

        max_items   = MAX_LIST_ITEMS
        a_str       = ""
        nl_if       = "\n"
        nl_if       = ""

        a_srep  = short_str( a_obj )

        if not details_only:
            a_str   = f"{xin}{a_str}for msg = {msg}"

            a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

            a_str   = f"{a_str}\n{xin}{INDENT2}type is = { str( type(a_obj) ) }"
            #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
            a_repr  = short_repr( a_obj )
            a_str   = f"{a_str}\n{xin}{INDENT2}repr            = {a_repr}"

        field_count   = a_obj.count()
        # a_str   = f"{a_str}\n{xin}{INDENT2}record field count()      = {a_obj.count() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}record isEmpty()       = {a_obj.isEmpty() }"

        a_str   = f"{a_str}\n{xin}{INDENT2}record field count()/isEmpty      = {a_obj.count() } / {a_obj.isEmpty() }"


        # fields themselfs are not interesting
        # a_str   = f"{a_str}\n{xin}{INDENT2}field( 0)       = {a_obj.field( 0 ) }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}field( 1)       = {a_obj.field( 1 ) }"


        # next with differing implementations
        # #
        # # a_str   = f"{a_str}\n{xin}{INDENT2}fieldName( 0)   = {a_obj.fieldName( 0 ) }"
        # # a_str   = f"{a_str}\n{xin}{INDENT2}field(1).value()= {a_obj.field( 0 ).value() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}00: name/value = {a_obj.fieldName( 0 )} /  {a_obj.field( 0 ).value() }"

        # # a_str   = f"{a_str}\n{xin}{INDENT2}fieldName( 1)   = {a_obj.fieldName( 1 ) }"
        # # a_str   = f"{a_str}\n{xin}{INDENT2}field(1).value()= {a_obj.field( 1 ).value() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}01: name/value = {a_obj.fieldName( 1 )} /  {a_obj.field( 1 ).value() }"

        for ix_field in range( 0,field_count ):
            a_str   = f"{a_str}\n{xin}{INDENT2}    {ix_field}: name/value = {a_obj.fieldName( ix_field )} /  {a_obj.field( ix_field ).value() }"
            field   = a_obj.field( ix_field )
            f       = field
            field_info   = ( f"{f.isAutoValue( ) = } {f.isGenerated( ) = } "
                             f"{f.isNull() = }  {f.isReadOnly( ) = } {f.isValid( ) = }    ")

            #a_str   = f"{a_str}\n{xin}{INDENT2}      {ix_field}: field_info = {field_info}"
            a_str   = f"{a_str}\n{xin}{INDENT2}      field_info = {field_info}"

        #a_str   = f"{a_str}\n{xin}{INDENT2}keyValues()       = {a_obj.keyValues() }"

        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_sql_field ( a_obj,
                        msg = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        ):
    """

    see records


    #import ia_qt
    ia_qt.q_sql_field( obj,
                                  msg            = "in test_db()...",
                                  include_dir    = True ) )


            Optional                      0
            Required                      1
            RequiredStatus                <class 'PyQt5.QtSql.QSqlField.RequiredStatus'>
            Unknown                       -1
            clear                         <built-in method clear of QSqlField object at 0x7f7354717a00>
            defaultValue                  <built-in method defaultValue of QSqlField object at 0x7f7354717a00>
            isAutoValue                   <built-in method isAutoValue of QSqlField object at 0x7f7354717a00>
            isGenerated                   <built-in method isGenerated of QSqlField object at 0x7f7354717a00>
            isNull                        <built-in method isNull of QSqlField object at 0x7f7354717a00>
            isReadOnly                    <built-in method isReadOnly of QSqlField object at 0x7f7354717a00>
            isValid                       <built-in method isValid of QSqlField object at 0x7f7354717a00>
            length                        <built-in method length of QSqlField object at 0x7f7354717a00>
            name                          <built-in method name of QSqlField object at 0x7f7354717a00>
            precision                     <built-in method precision of QSqlField object at 0x7f7354717a00>
            requiredStatus                <built-in method requiredStatus of QSqlField object at 0x7f7354717a00>
            setAutoValue                  <built-in method setAutoValue of QSqlField object at 0x7f7354717a00>
            setDefaultValue               <built-in method setDefaultValue of QSqlField object at 0x7f7354717a00>
            setGenerated                  <built-in method setGenerated of QSqlField object at 0x7f7354717a00>
            setLength                     <built-in method setLength of QSqlField object at 0x7f7354717a00>
            setName                       <built-in method setName of QSqlField object at 0x7f7354717a00>
            setPrecision                  <built-in method setPrecision of QSqlField object at 0x7f7354717a00>
            setReadOnly                   <built-in method setReadOnly of QSqlField object at 0x7f7354717a00>
            setRequired                   <built-in method setRequired of QSqlField object at 0x7f7354717a00>
            setRequiredStatus             <built-in method setRequiredStatus of QSqlField object at 0x7f7354717a00>
            setSqlType                    <built-in method setSqlType of QSqlField object at 0x7f7354717a00>
            setTableName                  <built-in method setTableName of QSqlField object at 0x7f7354717a00>
            setType                       <built-in method setType of QSqlField object at 0x7f7354717a00>
            setValue                      <built-in method setValue of QSqlField object at 0x7f7354717a00>
            tableName                     <built-in method tableName of QSqlField object at 0x7f7354717a00>
            type                          <built-in method type of QSqlField object at 0x7f7354717a00>
            typeID                        <built-in method typeID of QSqlField object at 0x7f7354717a00>
            value                         <built-in method value of QSqlField object at 0x7f7354717a00>

    """
    my_type       =  QSqlField
    my_type_str   = "QSqlField"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "

    if  isinstance(  a_obj, my_type ):

        max_items   = MAX_LIST_ITEMS
        a_str       = ""
        nl_if       = "\n"
        nl_if       = ""

        if msg is not None:
            a_str   = f"{xin}{a_str}for msg = {msg}"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_str   = f"{a_str}\n{xin}{INDENT2}type is = { str( type(a_obj) ) }"
        #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
        a_repr  = short_repr( a_obj )
        a_str   = f"{a_str}\n{xin}{INDENT2}repr    = {a_repr}"

        # a_str   = f"{a_str}\n{xin}{INDENT2}count()         = {a_obj.count() }"

        a_str   = f"{a_str}\n{xin}{INDENT2}type()       = {a_obj.type() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}typeID()       = {a_obj.typeID() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}value()       = {a_obj.value() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}length()       = {a_obj.length() }"

        if include_dir:
            a_str = f"{a_str}\n{xin} {dir_info( a_obj ) }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}isOpen()        = {a_obj.isOpen() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}tables()        = {a_obj.tables() }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_box_layout( a_obj,
                        msg      = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        ):
    """
    is ther a boxlayout --- yes and above it a qlayout

    """
    my_type       =  QBoxLayout
    my_type_str   = "QBoxLayout"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "

    if  isinstance(  a_obj, my_type ):

        max_items   = MAX_LIST_ITEMS
        a_str       = ""
        nl_if       = "\n"
        nl_if       = ""

        if msg is not None:
            a_str   = f"{xin}{a_str}for msg = {msg}"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_str   = f"{a_str}\n{xin}{INDENT2}type is = { str( type(a_obj) ) }"
        #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
        a_repr  = short_repr( a_obj )
        a_str   = f"{a_str}\n{xin}{INDENT2}repr         = {a_repr}"

        a_str   = f"{a_str}\n{xin}{INDENT2}children ()  = {a_obj.children () }"
        a_str   = f"{a_str}\n{xin}{INDENT2}count()      = {a_obj.count() }"

        a_str   = f"{a_str}\n{xin}{INDENT2}dumpObjectInfo() = {a_obj.dumpObjectInfo() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}dumpObjectTree() = {a_obj.dumpObjectTree() }"


        # a_str   = f"{a_str}\n{xin}{INDENT2}findChild()          = {a_obj.findChild() }"
        #     not enough arguments

        # a_str   = f"{a_str}\n{xin}{INDENT2}findChildren()    = {a_obj.findChildren() }"
        #     not enough arguments

        a_str   = f"{a_str}\n{xin}{INDENT2}geometry()          = {a_obj.geometry() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}isEnabled()         = {a_obj.isEnabled() }"

        if include_dir:
            a_str = a_str + dir_info( a_obj )

        # a_str   = f"{a_str}\n{xin}{INDENT2}lastInsertId()  = {a_obj.lastInsertId() }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# dispatch_dict[ QSqlRelationalTableModel ]   = (  q_sql_relational_table_model,       "QSqlRelationalTableModel" )
# ----------------------------------------
def  q_line_edit( a_obj,
                        msg      = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        ):
    """
    sometimes called a field
    QLineEdit()    info_about.ia_q_line_edit(  )
        print(  info_about.ia_q_line_edit( field, msg = None,  include_dir = True ) )

    """
    my_type       =  QLineEdit
    my_type_str   = "QLineEdit"


    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "


    if  isinstance(  a_obj, my_type ):

        max_items   = MAX_LIST_ITEMS
        a_str       = ""
        nl_if       = "\n"
        nl_if       = ""

        if msg is not None:
            a_str   = f"{xin}{a_str}for msg = {msg}"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_str   = f"{a_str}\n{xin}{INDENT2}type is = { str( type(a_obj) ) }"
        #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
        a_repr  = short_repr( a_obj )
        a_str   = f"{a_str}\n{xin}{INDENT2}repr    = {a_repr}"

        a_str   = f"{a_str}\n{xin}{INDENT2}alignment()          = {a_obj.alignment() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}cursorPosition()     = {a_obj.cursorPosition() }"

        a_str   = f"{a_str}\n{xin}{INDENT2}hasAcceptableInput() = {a_obj.hasAcceptableInput() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}isModified()         = {a_obj.isModified() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}maxLength()          = {a_obj.maxLength() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}placeholderText()    = {a_obj.placeholderText() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}validator()          = {a_obj.validator() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}text()               = {a_obj.text() }"

        if include_dir:
            a_str = a_str + dir_info( a_obj )

        # a_str   = f"{a_str}\n{xin}{INDENT2}lastInsertId()  = {a_obj.lastInsertId() }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_list( a_obj,
                        msg      = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        ):
    """
    sometimes called a field
    QLineEdit()    info_about.ia_q_line_edit(  )
        print(  info_about.ia_q_line_edit( field, msg = None,  include_dir = True ) )

    """
    my_type       =  QListWidget
    my_type_str   = "QListWidget"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "



    if  isinstance(  a_obj, my_type ):

        max_items   = MAX_LIST_ITEMS
        a_str       = ""
        nl_if       = "\n"
        nl_if       = ""

        if msg is not None:
            a_str   = f"{xin}{a_str}for msg = {msg}"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_str   = f"{a_str}\n{xin}{INDENT2}type is = { str( type(a_obj) ) }"
        #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
        a_repr  = short_repr( a_obj )
        a_str   = f"{a_str}\n{xin}{INDENT2}repr    = {a_repr}"


        a_str   = f"{a_str}\n{xin}{INDENT2}count()            = {a_obj.count() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}currentItem()      = {a_obj.currentItem() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}item( 0 ).text( ) = {a_obj.item( 0 ).text( ) }"

        current_item = a_obj.currentItem()
        if current_item:
            # Retrieve and show the text of the current item
            item_text = current_item.text()
        else:
             item_text = None

        a_str   = f"{a_str}\n{xin}{INDENT2}current_item.text() = {item_text}"
        # a_str   = f"{a_str}\n{xin}{INDENT2}item( 0 ).text( ) = {a_obj.item( 0 ).text( ) }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}isModified()         = {a_obj.isModified() }"

        if include_dir:
            a_str = a_str + dir_info( a_obj )

        # a_str   = f"{a_str}\n{xin}{INDENT2}lastInsertId()  = {a_obj.lastInsertId() }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_text_edit( a_obj,
                        msg      = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        ):
    """
    print(  ia_qt.q_text_edit( obj, msg = "what " )
    print(  ia_qt.q_text_edit( field, msg = None,  include_dir = True ) )
    """
    my_type       =  QTextEdit
    my_type_str   = "QTextEdit"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "

    if  isinstance(  a_obj, my_type ):

        max_items   = MAX_LIST_ITEMS
        a_str       = ""
        nl_if       = "\n"
        nl_if       = ""

        if msg is not None:
            a_str   = f"{xin}{a_str}for msg = {msg}"

        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_str   = f"{a_str}\n{xin}{INDENT2}type is = { str( type(a_obj) ) }"
        #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
        a_repr  = short_repr( a_obj )
        a_str   = f"{a_str}\n{xin}{INDENT2}repr    = {a_repr}"

        a_str   = f"{a_str}\n{xin}{INDENT2}toPlainText()            = {a_obj.toPlainText() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}currentItem()      = {a_obj.currentItem() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}item( 0 ).text( ) = {a_obj.item( 0 ).text( ) }"

        # current_item = a_obj.currentItem()
        # if current_item:
        #     # Retrieve and show the text of the current item
        #     item_text = current_item.text()
        # else:
        #      item_text = None

        # a_str   = f"{a_str}\n{xin}{INDENT2}current_item.text() = {item_text}"
        # a_str   = f"{a_str}\n{xin}{INDENT2}item( 0 ).text( ) = {a_obj.item( 0 ).text( ) }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}isModified()         = {a_obj.isModified() }"


        if include_dir:
            a_str = a_str + dir_info( a_obj )

        # a_str   = f"{a_str}\n{xin}{INDENT2}lastInsertId()  = {a_obj.lastInsertId() }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )

    return a_str

# ----------------------------------------
def  q_combo_box( a_obj,
                        msg      = None,
                        *,
                        max_len  = None,
                        xin      = "",
                        print_it = True,
                        sty      = "",
                        include_dir  = False,
                        ):
    """
    sometimes called a field
    QLineEdit()    info_about.ia_q_line_edit(  )
        print(  info_about.ia_q_line_edit( field, msg = None,  include_dir = True ) )

    """
    my_type       =  QComboBox
    my_type_str   = "QComboBox"

    if msg is None:
        msg  = default_msg( my_type_str )
    else:
        msg  = f"{msg_prefix}{msg} "




    if  isinstance(  a_obj, my_type ):

        max_items  = MAX_LIST_ITEMS
        a_str   = ""
        nl_if  = "\n"
        if msg is not None:
            a_str   = f"{xin}{a_str}for msg = {msg}"
        nl_if  = ""
        a_srep  = short_str( a_obj )
        a_str   = f"{a_str}{nl_if}{xin}{INDENT}>{a_srep}<"

        a_str   = f"{a_str}\n{xin}{INDENT2}type is = { str( type(a_obj) ) }"
        #a_str   = f"{a_str}\n{INDENT2}str     = {str( a_obj )}"
        a_repr  = short_repr( a_obj )
        a_str   = f"{a_str}\n{xin}{INDENT2}repr    = {a_repr}"


#         index_text           = self.combo_2.itemText( index )
#         index_valid          = current_text == index_text


# --------------

        a_str   = f"{a_str}\n{xin}{INDENT2}a_obj.count()          = {a_obj.count()}"
        # a_str   = f"{a_str}\n{xin}{INDENT2}a_obj.editable         = {a_obj.editable()}"  # think not in qt 5
        a_str   = f"{a_str}\n{xin}{INDENT2}a_obj.maxVisibleItems()= {a_obj.maxVisibleItems()}"

        a_str   = f"{a_str}\n{xin}{INDENT2}currentText()          = {a_obj.currentText() }"
        a_str   = f"{a_str}\n{xin}{INDENT2}currentIndex()         = {a_obj.currentIndex() }"
        current_index       = a_obj.currentIndex()
        current_index_text  =  a_obj.itemText( current_index )
        a_str   = f"{a_str}\n{xin}{INDENT2}current_index_text     = {current_index_text}"
        if current_index_text != a_obj.currentText():
            a_str   = f"{a_str}\n{xin} current index text not equal to current text"

        for ix in range( a_obj.count()):
                value_at_index =  a_obj.itemText( ix )
                a_str   = f"{a_str}\n{xin}    {INDENT2}value                  = {value_at_index}"


        # a_str   = f"{a_str}\n{xin}{INDENT2}hasAcceptableInput() = {a_obj.hasAcceptableInput() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}isModified()         = {a_obj.isModified() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}maxLength()          = {a_obj.maxLength() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}placeholderText()    = {a_obj.placeholderText() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}validator()          = {a_obj.validator() }"
        # a_str   = f"{a_str}\n{xin}{INDENT2}text()               = {a_obj.text() }"


        if include_dir:
            a_str = a_str + dir_info( a_obj )

        # a_str   = f"{a_str}\n{xin}{INDENT2}lastInsertId()  = {a_obj.lastInsertId() }"

    else:
        a_str   = not_instance( msg,  my_type, my_type_str,  a_obj, xin )

    if print_it:
        print( a_str )


    return a_str





# need to be after defines
# probably do the most specialized first
dispatch_dict[ QSqlRelationalTableModel ]   = (  q_sql_relational_table_model,       "QSqlRelationalTableModel" )
dispatch_dict[ QSqlQueryModel ]             = (  q_sql_query_model,  "QSqlQueryModel" )
dispatch_dict[ QSqlTableModel ]             = (  q_sql_table_model,  "QSqlTableModel" )
dispatch_dict[ QSqlQuery ]      = (  q_sql_query,        "QSqlQuery" )
dispatch_dict[ QSqlError ]      = (  q_sql_error,        "QSqlError" )
dispatch_dict[ QSqlDatabase ]   = (  q_sql_database,     "QSqlDatabase" )
dispatch_dict[ QSqlRecord ]     = (  q_sql_record,       "QSqlRecord" )
dispatch_dict[ QSqlField ]      = (  q_sql_field,         "QSqlField" )
dispatch_dict[ QLineEdit ]      = (  q_line_edit,         "QLineEdit" )
dispatch_dict[ QComboBox ]      = (  q_combo_box,         "QComboBox" )
dispatch_dict[ QTextEdit ]      = (  q_text_edit,         "QTextEdit" )

# ----------------------------------------
def  dir_info( a_obj, msg = "dir info:", ):
                        # *,
                        # max_len  = None,
                        # xin      = "",
                        # print_it = True,
                        # sty      = ""  ):
    """
    Purpose:
        list out some __dir__() info as a string



        <class 'PyQt5.QtSql.QSqlError.ErrorType'>
        databaseText
        a_atter = <built-in method databaseText of QSqlError object at 0x7f84245a0350>
        driverText
        a_atter = <built-in method driverText of QSqlError object at 0x7f84245a0350>
        isValid
        a_atter = <built-in method isValid of QSqlError object at 0x7f84245a0350>

        might be nice to shorten or declutter items

    """
    #msg       = f"directory (non standard items) for object of type {type( a_obj ) = }"
    msg       = f"directory (non standard items):"


    #print( msg )

    the_dir  = a_obj.__dir__()
    reduced_dir  = [ i_dir  for   i_dir in the_dir if i_dir not in common_dir_items ]
    reduced_dir.sort()
    current_str = ""
    for i_dir in reduced_dir:

            # clean it up a bit ??
            #print( i_dir )
            a_atter     =   getattr( a_obj, i_dir, None )
            # if a_atter.startswith( "<built-in method" ):
            #     a_atter  = "method"
            # if a_atter.startswith( "<built-in method" ):
            #     a_atter  = "method"

            #print( f"{i_dir= } .... {a_atter = }", flush = True )
            # to_columns( current_str, item_list, format_list = ( "{: <30}", "{:<30}" ), indent = "    "  ):

            current_str = to_columns( current_str, [ str( i_dir ), str( a_atter) ] )

    msg   = msg + "\n" + current_str

    return msg

#






# ---- eof

